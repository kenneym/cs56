----------------------------------------------------------------------------------
-- Company: 
-- Engineer: 
-- 
-- Create Date: 05/23/2019 03:00:33 PM
-- Design Name: 
-- Module Name: sci - Behavioral
-- Project Name: 
-- Target Devices: 
-- Tool Versions: 
-- Description: 
-- 
-- Dependencies: 
-- 
-- Revision:
-- Revision 0.01 - File Created
-- Additional Comments:
-- 
----------------------------------------------------------------------------------


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity SerialRx is
    Port (  clk    :       in STD_LOGIC;                       --the master clock
            RsRx     :      in STD_LOGIC;                       --serial data in
--			rx_shift :		out STD_LOGIC;						-- for debugging
            rx_data  :      out STD_LOGIC_VECTOR(7 downto 0);   --parallel data out
            rx_done_tick :  out STD_LOGIC);                     --data ready (done tick)
end SerialRx;

architecture Behavioral of SerialRx is


-- Serial constants:
constant clk_freq : integer := 10000000;
constant baud : integer := 115200;
constant n : integer := clk_freq/baud;
constant n_half : integer := n/2;



-- FSM Declaration:
type state_type is (waits, shifts, writes, done_tick);
signal current_state, next_state : state_type := waits;


-- Counters:
signal br_cnt : unsigned(11 downto 0) := x"000";
signal br_tick, half_tick : STD_LOGIC;

signal shift_cnt : unsigned(3 downto 0) := "0000"; -- number of bits shifted in (10 total)
signal shift_cnt_en, out_en, shift_cnt_r, done_tick_en: STD_LOGIC := '0';
signal rsrx_ff, rsrx_s : STD_LOGIC;
signal shift_reg : STD_LOGIC_VECTOR(9 downto 0) := "0000000000";
signal out_reg : STD_LOGIC_VECTOR(7 downto 0) := "00000000";

-- test signals



begin

	BaudRateClock:
	process(Clk)
	begin
		if rising_edge(Clk) then

			if br_cnt = n_half -1 then
				half_tick <= '1';
			end if;

			if br_cnt = n-1 then
				br_cnt <= x"000";
				br_tick <= '1';     -- emit tick every BAUD_COUNT clock cycles
			else
				br_cnt <= br_cnt+1;
				br_tick <= '0';
			end if;

		end if;
	end process BaudRateClock;




    nextStateLogic: process(current_state, RsRx, RsRx_S, shift_cnt, br_tick, half_tick)
	begin

        next_state <= current_state;

        shift_cnt_en <= '0';
        out_en <= '0';
        shift_cnt_r <= '0';
        done_tick_en <= '0';

		case (current_state) is
			
            when waits =>

                shift_cnt_r <= '1';
                if RsRx_S = '0' then
                    next_state <= shifts;
                end if;

            when shifts =>

				if half_tick = '1' then
					if shift_cnt = "0000" then -- first count
                        shift_cnt_en <= '1';
                    end if;

                elsif br_tick = '1' then
                    shift_cnt_en <= '1';
                end if;

                if shift_cnt = "1010" then
                    next_state <= writes;
                end if;

            when writes =>
                out_en <= '1';
                next_state <= done_tick;
                
            when done_tick =>
                done_tick_en <= '1';
                next_state <= waits;

         end case; 
    end process nextStateLogic;
    
    
    synchronize:process(clk, RsRx_FF, RsRx_S)
    begin
        if rising_edge(clk) then
            RsRx_FF <= RsRx;
            RsRx_S <= RsRx_FF;
        end if;
    end process synchronize;
    
    stateUpdate: process(clk)
    begin
        if rising_edge(clk) then
            current_state <= next_state;

			rx_done_tick <= '0';
			--rx_shift <= '0'; -- for debugging

            if shift_cnt_en = '1' then
                shift_cnt <= shift_cnt + 1;
			--	rx_shift <= '1'; 	-- for debugging
                shift_reg <= RsRx_s & shift_reg(9 downto 1);
            end if;

            if out_en = '1' then
                out_reg <= shift_reg(8 downto 1);
            end if;
            
            if done_tick_en = '1' then
                rx_done_tick <= '1';
            end if;

            if shift_cnt_r = '1' then
                shift_cnt <= "0000";
            end if;
        end if;

     end process stateUpdate;
     rx_data <= out_reg;

end Behavioral;
